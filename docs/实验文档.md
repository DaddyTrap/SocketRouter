# 虚拟路由实验
# SocketRouter

基于Socket来进行虚拟路由
## 基础项目信息

### 结点配置文件

```plain
{
  "name": String,
  "node_id": Number,
  "ip": "$ip",
  "port": $port,
  "topo": {
    "$node_id": {
      "real_ip": "$ip",
      "real_port": $port,
      "cost": Number
    }
  }
}
```

### 协议

换行符使用 `\n` 而非 `\r\n`

基本协议形式

```plain
SRC_ID $源结点NODE_ID
DST_ID $目标结点NODE_ID，-1表示广播 $序列号，如果是广播需要序列号进行受控洪泛
$数据包类型(DATA/ROUTE/BEAT) $携带数据类型(TXT/JPEG/PNG/...)/$使用的算法模式(LS/DV)/$心跳(BEAT)
$数据，支持二进制
```

#### DATA类型

文本：
```plain
SRC_ID 0
DST_ID 1
DATA TXT
Hello world, and this is the raw text data.
Feel free to use \n or \r\n here. It only depends on your application.
甚至可以写中文。
```



#### ROUTE类型

##### LS模式路由信息

广播自身的邻居情况：
```plain
SRC_ID 0
DST_ID -1 132
ROUTE LS
$NODE_ID_0 $LINK_COST_0
$NDOE_ID_1 $LINK_COST_1
...
```

##### DV模式路由信息

向邻居发送自身的邻居情况
```plain
SRC_ID 0
DST_ID 1
ROUTE DV
$NODE_ID_0 $LINK_COST_0
$NDOE_ID_1 $LINK_COST_1
...
```

##### 请求路由信息

向邻居发送路由信息请求
```plain
SRC_ID 0
DST_ID 1
ROUTE REQ
REQ
```

#### BEAT类型

广播心跳信息：
```plain
SRC_ID 0
DST_ID -1 123
BEAT BEAT
ALIVE
```

### UI界面
![UI](./assets/ui_description.png)

### 项目逻辑

#### 总述

项目使用Python3代码编写，基于 **UDP协议** 进行路由信息交换

+ 结点: 一个虚拟路由结点
  + 一台物理的机器上可以部署不止一个虚拟结点，在本项目中，(IP, port) 可作为一个结点的唯一标识。即，在同一台物理机器上，可以部署多个虚拟结点，只需要配置不同端口即可。
+ node id: 用作结点的唯一标识，可类比真实网络中的IP
  + 虽然 (IP, port) 也是唯一标识，但为方便起见，增加一个node id来替代 (IP, port)


根据面向对象的思想，使用了 **类** 的概念。本例中，有5个类：

+ `BaseRouteNode` 包含一个路由结点的基础功能，包括基础的协议解析、发送/接收数据、宕机检测、心跳包管理等功能
+ `LSRouteNode` 继承 `BaseRouteNode` 包含LS路由结点的功能，会对 `BaseRoute` 进行一定特化
+ `DVRouteNode` 继承 `BaseRouteNode` ，包含DV路由结点的功能，会对 `BaseRoute` 进行一定特化
+ `CentralNode` 继承 `LSRouteNdoe`，包含在有中心控制器时，中心控制器的功能
+ `CentralNormalNode` 继承 `LSRouteNdoe`，包含在有中心控制器时，普通节点的功能

当数据包到达时，会由 `BaseRouteNode` 的成员方法接收并将报文内容根据协议转为python中的 **字典(dict)**，再根据在该字典中的值判断报文属于哪一类型，根据类型再转到恰当函数中处理：如路由信息，转到各个类中实现的 `route_obj_handler` 处理；数据信息，转到 `data_obj_handler` 进行处理等。

#### 算法部分
对于非中心结点，有LS（链路状态）与DV（距离向量）两种结点，对应使用了相应算法，算法主体代码如下:
```python
def dv_algo(other_node_id, other_cost_table, source_cost_table, forward_table):
    changeFlag = False
    for k,v in [i for i in forward_table.items()]:
        if v == other_node_id and k not in other_cost_table and k != other_node_id:
            source_cost_table.pop(k)
            forward_table.pop(k)
    # 上面的操作用于处理结点down掉但结点没有获得信息的情况
    for k,v in other_cost_table.items():
        if k not in source_cost_table or source_cost_table[k] > source_cost_table[other_node_id] + other_cost_table[k]:
            source_cost_table[k] = source_cost_table[other_node_id] + other_cost_table[k]
            forward_table[k] = other_node_id
            changeFlag = True
    return changeFlag

def ls_algo(source_node_id, topo, forward_table):
if len(topo) == 0:
    return

if source_node_id in topo:
    pass
else:
    return
N_ = set()
N_.add(source_node_id)
D = {}
p = {}
nodes = set()
for key, val in topo.items():
    for k, v in val.items():
        nodes.add(key)
        nodes.add(k)
for n in nodes:
    if n in topo[source_node_id]:
        D[n] = topo[source_node_id][n]
        p[n] = source_node_id
    else:
        D[n] = sys.maxsize
D[source_node_id] = 0
while len(N_) != len(nodes):
    tmp_list = sorted(D.items(), key=lambda asd: asd[1])
    for k, v in tmp_list:
        if k not in N_:
            N_.add(k)
            if k in topo:
                for key, val in topo[k].items():
                    if (topo[k][key] + D[k] < D[key]):
                        p[key] = k
                        D[key] = topo[k][key] + D[k]
            break
for k, v in p.items():
    if v == source_node_id:
        tk = k
        last = v
        while tk != last:
            last = tk
            forward_table[tk] = k
            for key, val in p.items():
                if val == tk:
                    tk = key
                    break
return D
```
#### 路由信息处理

因类型(DV或LS)的不同，会有不同的路由信息处理策略

##### LS

LS结点的路由信息是：该结点的相邻结点及其链路费用

此处描述LS结点的逻辑：

1. start时，广播一个 **路由信息请求包**(用于获取当前拓扑信息)，并广播一个自身路由信息(包含自身的邻居结点情况)
2. start后，开始侦测数据包的接收情况
3. 接收到路由信息，根据路由信息修改自身当前保存的全局拓扑图，若拓扑图更新，则调用LS算法计算新的费用表和转发表
4. 定时广播自身信息、检查宕机情况，继续侦测数据包接收情况(回到3.)

##### DV

DV结点的路由信息是：当前所知的，到达邻居结点的最低费用

此处描述DV结点的逻辑

1. start时，向邻居发送一个 **路由信息请求包**(用于请求邻居向外发送器路由信息)，并向邻居发送自身路由信息(包含当前所知的到达邻居结点的最低费用)
2. start后，开始侦测数据包的接收情况
3. 接收到路由信息，根据路由信息直接调用DV算法计算新的费用表和转发表
4. 定时广播自身信息、检查宕机情况，继续侦测数据包接收情况(回到3.)

##### CLS (Center LS)

#### 路由广播策略

参考一般的网络中使用一个特殊IP(子网掩码为0的位置全为1)作为广播地址，本项目中采用特殊的

#### 广播控制策略

## 运行示例
### 测试拓扑图
![Topo 0](./assets/topo_0.png)
边上数字代表链路代价
### 测试数据
#### 数据以数字代替字母，采用json格式。每个结点对应一份json数据
```json
{
  "name": "node1",
  "node_id": 1,
  "ip": "127.0.0.1",
  "port": 8000,
  "topo": {
    "2": {
      "real_ip": "127.0.0.1",
      "real_port": 8001,
      "cost": 10
    },
    "3": {
      "real_ip": "127.0.0.1",
      "real_port": 8002,
      "cost": 10
    },
    "4": {
      "real_ip": "127.0.0.1",
      "real_port": 8003,
      "cost": 20
    }
  }
}
// for node 1

{
  "name": "node2",
  "node_id": 2,
  "ip": "127.0.0.1",
  "port": 8001,
  "topo": {
    "1": {
      "real_ip": "127.0.0.1",
      "real_port": 8000,
      "cost": 10
    },
    "3": {
      "real_ip": "127.0.0.1",
      "real_port": 8002,
      "cost": 10
    },
    "4": {
      "real_ip": "127.0.0.1",
      "real_port": 8003,
      "cost": 5
    }
  }
}
// for node 2

{
  "name": "node3",
  "node_id": 3,
  "ip": "127.0.0.1",
  "port": 8002,
  "topo": {
    "1": {
      "real_ip": "127.0.0.1",
      "real_port": 8000,
      "cost": 10
    },
    "2": {
      "real_ip": "127.0.0.1",
      "real_port": 8001,
      "cost": 10
    },
    "4": {
      "real_ip": "127.0.0.1",
      "real_port": 8003,
      "cost": 5
    },
    "5": {
      "real_ip": "127.0.0.1",
      "real_port": 8004,
      "cost": 5
    }
  }
}
// for node 3

{
  "name": "node4",
  "node_id": 4,
  "ip": "127.0.0.1",
  "port": 8003,
  "topo": {
    "1": {
      "real_ip": "127.0.0.1",
      "real_port": 8000,
      "cost": 20
    },
    "2": {
      "real_ip": "127.0.0.1",
      "real_port": 8001,
      "cost": 5
    },
    "3": {
      "real_ip": "127.0.0.1",
      "real_port": 8002,
      "cost": 5
    },
    "5": {
      "real_ip": "127.0.0.1",
      "real_port": 8004,
      "cost": 5
    }
  }
}
// for node 4

{
  "name": "node5",
  "node_id": 5,
  "ip": "127.0.0.1",
  "port": 8004,
  "topo": {
    "3": {
      "real_ip": "127.0.0.1",
      "real_port": 8002,
      "cost": 5
    },
    "4": {
      "real_ip": "127.0.0.1",
      "real_port": 8003,
      "cost": 5
    }
  }
}
// for node 5
```



### 实际运行效果

